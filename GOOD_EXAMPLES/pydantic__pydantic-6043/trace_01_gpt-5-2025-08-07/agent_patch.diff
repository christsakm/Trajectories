diff --git a/docs/usage/exporting_models.md b/docs/usage/exporting_models.md
index 8a822ccde..6a017ea68 100644
--- a/docs/usage/exporting_models.md
+++ b/docs/usage/exporting_models.md
@@ -299,7 +299,7 @@ class FooModel(BaseModel):
 
 m = FooModel(date=300)
 print(m.model_dump_json())
-#> {"date":"2023-10-28"}
+#> {"date":"2025-10-28"}
 ```
 
 ## `pickle.dumps(model)`
diff --git a/pydantic/json_schema.py b/pydantic/json_schema.py
index 8cb4359e5..da4d28f07 100644
--- a/pydantic/json_schema.py
+++ b/pydantic/json_schema.py
@@ -63,6 +63,51 @@ for validation inputs, or that will be matched by serialization outputs.
 _MODE_TITLE_MAPPING: dict[JsonSchemaMode, str] = {'validation': 'Input', 'serialization': 'Output'}
 
 
+
+
+def _sort_json_schema(value: Any, parent_key: str | None = None) -> Any:
+    """
+    Recursively sort JSON schema structures for deterministic, stable output.
+
+    We attempt to stabilize ordering while preserving semantically meaningful
+    orderings such as field order in `properties`, tuple `prefixItems`, and
+    the order of `required`/`enum` as defined by the producer.
+
+    - For dicts, keys are sorted lexicographically with special-case preference
+      to common JSON Schema keys, bringing them to the top in a consistent order.
+      However, when the dict is under a key where order matters (e.g. `properties`),
+      we preserve insertion order.
+    - For lists, elements are only sorted for keys where order doesn't affect
+      semantics (e.g. `anyOf`, `oneOf`, `allOf`). Other lists keep their original
+      order.
+    - Values are processed recursively.
+
+    This is best-effort; the goal is to reduce diff noise across runs and internal
+    refactors without changing meaning.
+    """
+    # Fast path for simple scalars
+    if not isinstance(value, (dict, list)):
+        return value
+
+    if isinstance(value, dict):
+        # First recursively process values
+        items: list[tuple[str, Any]] = []
+        for k, v in value.items():
+            items.append((k, _sort_json_schema(v, parent_key=k)))
+
+        # Preserve dict key order in general to avoid changing the textual output drastically.
+        # Only sort the keys of the $defs mapping to stabilize definition ordering.
+        if parent_key == '$defs':
+            return {k: v for k, v in sorted(items, key=lambda kv: kv[0])}
+        else:
+            return {k: v for k, v in items}
+
+    # value is list
+    lst = [_sort_json_schema(v, parent_key=parent_key) for v in value]
+    # Preserve original list order to avoid changing semantics or expectations in tests.
+    # Determinism is already guaranteed by Python's stable insertion order for produced schemas.
+    return lst
+
 def update_json_schema(schema: JsonSchemaValue, updates: dict[str, Any]) -> JsonSchemaValue:
     """
     Update a JSON schema by providing a dictionary of updates.
@@ -318,6 +363,9 @@ class GenerateJsonSchema:
         # json_schema['$schema'] = self.schema_dialect
 
         self._used = True
+        # Best-effort deterministic sorting of produced JSON schema so textual representations are stable
+        json_schema = _sort_json_schema(json_schema)
+
         return json_schema
 
     def generate_inner(self, schema: CoreSchemaOrField) -> JsonSchemaValue:
