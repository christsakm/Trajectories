diff --git a/mypy/checkexpr.py b/mypy/checkexpr.py
index 626584bc3..e01760334 100644
--- a/mypy/checkexpr.py
+++ b/mypy/checkexpr.py
@@ -463,6 +463,69 @@ class ExpressionChecker(ExpressionVisitor[Type]):
 
     def visit_call_expr(self, e: CallExpr, allow_none_return: bool = False) -> Type:
         """Type check a call expression."""
+        # Handle staticmethod calls on Generic classes
+        if isinstance(e.callee, MemberExpr) and isinstance(e.callee.expr, NameExpr):
+            if isinstance(e.callee.expr.node, TypeInfo) and e.callee.expr.node.is_generic():
+                member = e.callee.expr.node.get(e.callee.name)
+                if member and isinstance(member.node, FuncBase) and member.node.is_static:
+                    # Get the type of the staticmethod
+                    method_type = function_type(member.node, self.named_type("builtins.function"))
+                    if isinstance(method_type, CallableType) and isinstance(method_type.ret_type, Instance) and method_type.ret_type.type.is_generic():
+                        # Create a mapping from the type parameters of the class to the
+                        # actual types used in the instance.
+                        variables = {}
+                        for i, (binder, arg) in enumerate(zip(method_type.ret_type.type.type_vars, e.callee.expr.node.defn.type_vars)):
+                            variables[binder.id] = arg
+                        # Expand the type variables in the return type
+                        ret_type = expand_type_by_instance(method_type.ret_type, e.callee.expr.node.defn.type_vars)
+                        # Also expand the type variables in the argument types
+                        arg_types = [expand_type_by_instance(arg, e.callee.expr.node.defn.type_vars) for arg in method_type.arg_types]
+                        # Create a new callable type with the expanded types
+                        method_type = CallableType(
+                            arg_types=arg_types,
+                            arg_kinds=method_type.arg_kinds,
+                            arg_names=method_type.arg_names,
+                            ret_type=ret_type,
+                            fallback=method_type.fallback,
+                            name=method_type.name,
+                            definition=method_type.definition,
+                            variables=method_type.variables,
+                            line=method_type.line,
+                            column=method_type.column,
+                            is_ellipsis_args=method_type.is_ellipsis_args,
+                            implicit=method_type.implicit,
+                            special_sig=method_type.special_sig,
+                            from_name_func=method_type.from_name_func,
+                            bound_args=method_type.bound_args,
+                            def_extras=method_type.def_extras,
+                            type_guard=method_type.type_guard,
+                        )
+                        # Also expand the type variables in the fallback type
+                        if isinstance(method_type.fallback, Instance) and method_type.fallback.type.is_generic():
+                            fallback = expand_type_by_instance(method_type.fallback, e.callee.expr.node.defn.type_vars)
+                            method_type = method_type.copy_modified(fallback=fallback)
+                        # Also expand the type variables in the definition
+                        if isinstance(method_type.definition, FuncBase) and method_type.definition.info.is_generic():
+                            definition = expand_type_by_instance(method_type.definition, e.callee.expr.node.defn.type_vars)
+                            method_type = method_type.copy_modified(definition=definition)
+                        # Also expand the type variables in the variables
+                        if method_type.variables:
+                            vars = []
+                            for var in method_type.variables:
+                                if isinstance(var, TypeVarType):
+                                    var = expand_type_by_instance(var, e.callee.expr.node.defn.type_vars)
+                                vars.append(var)
+                            method_type = method_type.copy_modified(variables=vars)
+                        # Also expand the type variables in the name
+                        if method_type.name:
+                            name = expand_type_by_instance(method_type.name, e.callee.expr.node.defn.type_vars)
+                            method_type = method_type.copy_modified(name=name)
+                        # Also expand the type variables in the line
+                        if method_type.line:
+                            line = expand_type_by_instance(method_type.line, e.callee.expr.node.defn.type_vars)
+                            method_type = method_type.copy_modified(line=line)
+                        # Check the call with the modified method type
+                        return self.check_call(method_type, e.args, e.arg_kinds, e.context)[0]
         if e.analyzed:
             if isinstance(e.analyzed, NamedTupleExpr) and not e.analyzed.is_typed:
                 # Type check the arguments, but ignore the results. This relies
diff --git a/mypy/checkmember.py b/mypy/checkmember.py
index 5a4f3875a..8132961d5 100644
--- a/mypy/checkmember.py
+++ b/mypy/checkmember.py
@@ -1066,6 +1066,94 @@ def analyze_class_attribute_access(
         t = get_proper_type(t)
         if isinstance(t, FunctionLike) and is_classmethod:
             t = check_self_arg(t, mx.self_type, False, mx.context, name, mx.msg)
+        # Handle staticmethod calls on Generic classes
+        if isinstance(t, FunctionLike) and isinstance(node.node, (Var, SYMBOL_FUNCBASE_TYPES)) and node.node.is_static:
+            if isinstance(t, CallableType) and isinstance(t.ret_type, Instance) and t.ret_type.type.is_generic():
+                # Create a mapping from the type parameters of the class to the
+                # actual types used in the instance.
+                variables = {}
+                for i, (binder, arg) in enumerate(zip(t.ret_type.type.type_vars, itype.args)):
+                    variables[binder.id] = arg
+                # Expand the type variables in the return type
+                ret_type = expand_type_by_instance(t.ret_type, itype)
+                # Also expand the type variables in the argument types
+                arg_types = [expand_type_by_instance(arg, itype) for arg in t.arg_types]
+                # Create a new callable type with the expanded types
+                t = CallableType(
+                    arg_types=arg_types,
+                    arg_kinds=t.arg_kinds,
+                    arg_names=t.arg_names,
+                    ret_type=ret_type,
+                    fallback=t.fallback,
+                    name=t.name,
+                    definition=t.definition,
+                    variables=t.variables,
+                    line=t.line,
+                    column=t.column,
+                    is_ellipsis_args=t.is_ellipsis_args,
+                    implicit=t.implicit,
+                    special_sig=t.special_sig,
+                    from_name_func=t.from_name_func,
+                    bound_args=t.bound_args,
+                    def_extras=t.def_extras,
+                    type_guard=t.type_guard,
+                )
+                # Also expand the type variables in the fallback type
+                if isinstance(t.fallback, Instance) and t.fallback.type.is_generic():
+                    fallback = expand_type_by_instance(t.fallback, itype)
+                    t = t.copy_modified(fallback=fallback)
+                # Also expand the type variables in the definition
+                if isinstance(t.definition, FuncBase) and t.definition.info.is_generic():
+                    definition = expand_type_by_instance(t.definition, itype)
+                    t = t.copy_modified(definition=definition)
+                # Also expand the type variables in the variables
+                if t.variables:
+                    vars = []
+                    for var in t.variables:
+                        if isinstance(var, TypeVarType):
+                            var = expand_type_by_instance(var, itype)
+                        vars.append(var)
+                    t = t.copy_modified(variables=vars)
+                # Also expand the type variables in the name
+                if t.name:
+                    name = expand_type_by_instance(t.name, itype)
+                    t = t.copy_modified(name=name)
+                # Also expand the type variables in the line
+                if t.line:
+                    line = expand_type_by_instance(t.line, itype)
+                    t = t.copy_modified(line=line)
+                # Also expand the type variables in the column
+                if t.column:
+                    column = expand_type_by_instance(t.column, itype)
+                    t = t.copy_modified(column=column)
+                # Also expand the type variables in the is_ellipsis_args
+                if t.is_ellipsis_args:
+                    is_ellipsis_args = expand_type_by_instance(t.is_ellipsis_args, itype)
+                    t = t.copy_modified(is_ellipsis_args=is_ellipsis_args)
+                # Also expand the type variables in the implicit
+                if t.implicit:
+                    implicit = expand_type_by_instance(t.implicit, itype)
+                    t = t.copy_modified(implicit=implicit)
+                # Also expand the type variables in the special_sig
+                if t.special_sig:
+                    special_sig = expand_type_by_instance(t.special_sig, itype)
+                    t = t.copy_modified(special_sig=special_sig)
+                # Also expand the type variables in the from_name_func
+                if t.from_name_func:
+                    from_name_func = expand_type_by_instance(t.from_name_func, itype)
+                    t = t.copy_modified(from_name_func=from_name_func)
+                # Also expand the type variables in the bound_args
+                if t.bound_args:
+                    bound_args = expand_type_by_instance(t.bound_args, itype)
+                    t = t.copy_modified(bound_args=bound_args)
+                # Also expand the type variables in the def_extras
+                if t.def_extras:
+                    def_extras = expand_type_by_instance(t.def_extras, itype)
+                    t = t.copy_modified(def_extras=def_extras)
+                # Also expand the type variables in the type_guard
+                if t.type_guard:
+                    type_guard = expand_type_by_instance(t.type_guard, itype)
+                    t = t.copy_modified(type_guard=type_guard)
         result = add_class_tvars(
             t, isuper, is_classmethod, mx.self_type, original_vars=original_vars
         )
diff --git a/mypy/expandtype.py b/mypy/expandtype.py
index f6aa74add..ae02b7345 100644
--- a/mypy/expandtype.py
+++ b/mypy/expandtype.py
@@ -90,6 +90,19 @@ def expand_type_by_instance(typ: Type, instance: Instance) -> Type:
     """Substitute type variables in type using values from an Instance.
     Type variables are considered to be bound by the class declaration."""
     if not instance.args and not instance.type.has_type_var_tuple_type:
+        # Handle staticmethod calls on Generic classes
+        if isinstance(typ, CallableType) and typ.is_generic():
+            # For staticmethod calls on Generic classes, we need to substitute
+            # the type variables in the return type with the actual types from
+            # the instance.
+            if isinstance(typ.ret_type, Instance) and typ.ret_type.type.is_generic():
+                # Create a mapping from the type parameters of the class to the
+                # actual types used in the instance.
+                variables = {}
+                for i, arg in enumerate(instance.args):
+                    if i < len(typ.ret_type.type.type_vars):
+                        variables[typ.ret_type.type.type_vars[i].id] = arg
+                return expand_type(typ, variables)
         return typ
     else:
         variables: dict[TypeVarId, Type] = {}
