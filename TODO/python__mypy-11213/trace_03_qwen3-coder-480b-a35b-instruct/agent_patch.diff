diff --git a/mypy/checker.py b/mypy/checker.py
index 11499d6b5..559a2bc40 100644
--- a/mypy/checker.py
+++ b/mypy/checker.py
@@ -4981,7 +4981,7 @@ class TypeChecker(NodeVisitor[None], CheckerPluginInterface):
         """
         return (self.options.check_untyped_defs
                 or not self.dynamic_funcs
-                or not self.dynamic_funcs[-1])
+                or not any(self.dynamic_funcs))
 
     def lookup(self, name: str, kind: int) -> SymbolTableNode:
         """Look up a definition from the symbol table with the given name.
diff --git a/mypy/checkexpr.py b/mypy/checkexpr.py
index 00e3757a3..0447610ad 100644
--- a/mypy/checkexpr.py
+++ b/mypy/checkexpr.py
@@ -3505,18 +3505,26 @@ class ExpressionChecker(ExpressionVisitor[Type]):
         inferred_type, type_override = self.infer_lambda_type_using_context(e)
         if not inferred_type:
             self.chk.return_types.append(AnyType(TypeOfAny.special_form))
+            # Manage dynamic_funcs like check_func_item does
+            self.chk.dynamic_funcs.append(e.is_dynamic() and not type_override)
             # Type check everything in the body except for the final return
             # statement (it can contain tuple unpacking before return).
             with self.chk.scope.push_function(e):
-                # Lambdas can have more than one element in body,
-                # when we add "fictional" AssigmentStatement nodes, like in:
-                # `lambda (a, b): a`
-                for stmt in e.body.body[:-1]:
-                    stmt.accept(self.chk)
-                # Only type check the return expression, not the return statement.
-                # This is important as otherwise the following statements would be
-                # considered unreachable. There's no useful type context.
-                ret_type = self.accept(e.expr(), allow_none_return=True)
+                # Only check the lambda body if we're in a checked function
+                if self.chk.in_checked_function():
+                    # Lambdas can have more than one element in body,
+                    # when we add "fictional" AssigmentStatement nodes, like in:
+                    # `lambda (a, b): a`
+                    for stmt in e.body.body[:-1]:
+                        stmt.accept(self.chk)
+                    # Only type check the return expression, not the return statement.
+                    # This is important as otherwise the following statements would be
+                    # considered unreachable. There's no useful type context.
+                    ret_type = self.accept(e.expr(), allow_none_return=True)
+                else:
+                    # In unchecked functions, use Any for the return type
+                    ret_type = AnyType(TypeOfAny.special_form)
+            self.chk.dynamic_funcs.pop()
             fallback = self.named_type('builtins.function')
             self.chk.return_types.pop()
             return callable_type(e, fallback, ret_type)
@@ -3524,10 +3532,15 @@ class ExpressionChecker(ExpressionVisitor[Type]):
             # Type context available.
             self.chk.return_types.append(inferred_type.ret_type)
             self.chk.check_func_item(e, type_override=type_override)
-            if e.expr() not in self.chk.type_map:
-                # TODO: return expression must be accepted before exiting function scope.
-                self.accept(e.expr(), allow_none_return=True)
-            ret_type = self.chk.type_map[e.expr()]
+            # Only check the return expression if we're in a checked function
+            if self.chk.in_checked_function():
+                if e.expr() not in self.chk.type_map:
+                    # TODO: return expression must be accepted before exiting function scope.
+                    self.accept(e.expr(), allow_none_return=True)
+                ret_type = self.chk.type_map[e.expr()]
+            else:
+                # In unchecked functions, use Any for the return type
+                ret_type = AnyType(TypeOfAny.special_form)
             self.chk.return_types.pop()
             return replace_callable_return_type(inferred_type, ret_type)
 
diff --git a/reproduce.py b/reproduce.py
new file mode 100644
index 000000000..da956627a
--- /dev/null
+++ b/reproduce.py
@@ -0,0 +1,6 @@
+def f():
+    return UNDEFINED
+
+
+def g():
+    return lambda x: UNDEFINED in x
\ No newline at end of file
diff --git a/simple_test.py b/simple_test.py
new file mode 100644
index 000000000..7e53223ea
--- /dev/null
+++ b/simple_test.py
@@ -0,0 +1,4 @@
+def f():
+    return UNDEFINED
+
+x = lambda: UNDEFINED
\ No newline at end of file
diff --git a/test_direct.py b/test_direct.py
new file mode 100644
index 000000000..fc6cfa329
--- /dev/null
+++ b/test_direct.py
@@ -0,0 +1,6 @@
+def f():
+    return UNDEFINED
+
+def g():
+    x = UNDEFINED
+    return x
\ No newline at end of file
diff --git a/test_direct_vs_lambda.py b/test_direct_vs_lambda.py
new file mode 100644
index 000000000..66b920250
--- /dev/null
+++ b/test_direct_vs_lambda.py
@@ -0,0 +1,8 @@
+def f():
+    return UNDEFINED
+
+def g():
+    return lambda x: UNDEFINED in x
+
+x = UNDEFINED
+y = lambda: UNDEFINED
\ No newline at end of file
diff --git a/test_original.py b/test_original.py
new file mode 100644
index 000000000..da956627a
--- /dev/null
+++ b/test_original.py
@@ -0,0 +1,6 @@
+def f():
+    return UNDEFINED
+
+
+def g():
+    return lambda x: UNDEFINED in x
\ No newline at end of file
diff --git a/test_semantic.py b/test_semantic.py
new file mode 100644
index 000000000..fc6cfa329
--- /dev/null
+++ b/test_semantic.py
@@ -0,0 +1,6 @@
+def f():
+    return UNDEFINED
+
+def g():
+    x = UNDEFINED
+    return x
\ No newline at end of file
